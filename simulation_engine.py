# -*- coding: utf-8 -*-
"""Final Cafeteria Optimization

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DHdQzC_Pmup7WsOibJgItYg5TSO8xuwF
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import math

# --- CONFIGURATION ---
NUM_RUNS = 80000
# Wage Logic
WAGE_NORMAL = 11000  # Per hour (0-6 hours)
WAGE_OT = 16000      # Per hour (>6 hours)

# Profit Logic
REVENUE_PER_MEAL = 4000
COST_PER_WAIT_HOUR = 200
MAX_WAIT_TOLERANCE = 8.0

# Block Data
BLOCKS = [
    {"id": 1, "duration": 3, "lambda": 40}, # 8am - 11am
    {"id": 2, "duration": 3, "lambda": 80}, # 11am - 2pm
    {"id": 3, "duration": 3, "lambda": 20}, # 2pm - 5pm
    {"id": 4, "duration": 3, "lambda": 30}  # 5pm - 8pm
]

# Service Rates (Meals per hour)
MU_FAST = 30.0        # 100% Efficiency (0-4 hours)
MU_MEDIUM = 24.0      # 80% Efficiency (4-6 hours)
MU_SLOW = 15.0        # 50% Efficiency (>6 hours)

def get_overlap(start, end, zone_start, zone_end):
    """Helper for overlapping time intervals."""
    overlap_start = max(start, zone_start)
    overlap_end = min(end, zone_end)
    return max(0, overlap_end - overlap_start)

def run_simulation(staff_schedule):
    """
    Runs a single day simulation
    """

    # 1. MACRO SETUP
    peak_staff = max(staff_schedule)
    sorted_sched = sorted(staff_schedule)
    lowest_two_sum = sorted_sched[0] + sorted_sched[1]
    implied_staff_count = min(6, max(peak_staff, lowest_two_sum))

    # Define Thresholds
    limit_fast = implied_staff_count * 4.0
    limit_medium = implied_staff_count * 6.0

    cumulative_hours_used = 0

    total_wait_minutes = 0
    total_revenue = 0
    total_wages = 0
    total_lost_revenue_balking = 0

    queue_backlog = 0
    block_avg_waits = []

    for i, block in enumerate(BLOCKS):
        num_servers = int(staff_schedule[i])
        duration = block["duration"]
        hours_needed_this_block = num_servers * duration

        # 2. CALCULATE EFFECTIVE RATE (Weighted Average Fatigue)
        start_h = cumulative_hours_used
        end_h = cumulative_hours_used + hours_needed_this_block

        hours_fast = get_overlap(start_h, end_h, 0, limit_fast)
        hours_medium = get_overlap(start_h, end_h, limit_fast, limit_medium)
        hours_slow = get_overlap(start_h, end_h, limit_medium, 999999)

        cumulative_hours_used += hours_needed_this_block

        if hours_needed_this_block > 0:
            weighted_rate = (
                (hours_fast * MU_FAST) +
                (hours_medium * MU_MEDIUM) +
                (hours_slow * MU_SLOW)
            ) / hours_needed_this_block
        else:
            weighted_rate = MU_FAST

        capacity_rate = num_servers * weighted_rate # Total System Output / hr

        # --- 3. BALKING LOGIC ---
        # Estimate the "Visible Wait" for a customer arriving right now.
        if capacity_rate > 0:
            visible_wait_mins = (queue_backlog / (capacity_rate / 60))
        else:
            visible_wait_mins = 999

        # Balking Probability Function (Exponential Decay)
        p_join = math.exp(-1.0 * (visible_wait_mins / MAX_WAIT_TOLERANCE))

        # 4. STOCHASTIC SIMULATION
        # Generate Potential Customers (Raw Demand)
        expected_raw_arrivals = block["lambda"] * duration
        raw_arrivals = np.random.poisson(expected_raw_arrivals)

        # Determine how many ACTUALLY join (Binomial trial)
        joined_arrivals = np.random.binomial(raw_arrivals, p_join)

        # Calculate Lost Customers (Balkers)
        balked_customers = raw_arrivals - joined_arrivals
        total_lost_revenue_balking += (balked_customers * REVENUE_PER_MEAL)

        # Continue simulation with only JOINED arrivals
        arrival_rate = joined_arrivals / duration
        rho = arrival_rate / capacity_rate if capacity_rate > 0 else 999

        # A. Steady State Wait (M/M/k)
        if rho >= 0.98: # Use safe threshold
            overflow = arrival_rate - capacity_rate
            if arrival_rate > 0:
                W_steady_mins = ((overflow * duration) / (2 * arrival_rate)) * 60 + 10
            else:
                W_steady_mins = 0
        else:
            s = num_servers
            try:
                if arrival_rate > 1e-9:
                    ratio = arrival_rate / weighted_rate
                    sum_p0 = sum([(ratio**n) / math.factorial(n) for n in range(s)])
                    term_s = (ratio**s) / (math.factorial(s) * (1 - rho))
                    P0 = 1.0 / (sum_p0 + term_s)
                    Lq = (P0 * (ratio**s) * rho) / (math.factorial(s) * (1 - rho)**2)
                    W_steady_mins = (Lq / arrival_rate) * 60
                else:
                    W_steady_mins = 0
            except:
                W_steady_mins = 999

        # B. Backlog Wait
        if num_servers > 0:
            W_backlog_mins = queue_backlog / (capacity_rate / 60)
        else:
            W_backlog_mins = 999

        block_wait_avg = W_steady_mins + W_backlog_mins
        block_avg_waits.append(block_wait_avg)

        # Flow Update
        total_demand = queue_backlog + joined_arrivals
        max_capacity_this_block = capacity_rate * duration
        served_count = min(total_demand, max_capacity_this_block)
        queue_backlog = total_demand - served_count

        # Financials
        if block_wait_avg > MAX_WAIT_TOLERANCE:
            revenue_this_block = 0
        else:
            revenue_this_block = served_count * REVENUE_PER_MEAL

        total_revenue += revenue_this_block
        total_wait_minutes += (block_wait_avg * served_count)

        wages_this_block = ((hours_fast + hours_medium) * WAGE_NORMAL) + (hours_slow * WAGE_OT)
        total_wages += wages_this_block

    # --- END OF DAY ---
    max_wait_experienced = max(block_avg_waits)
    valid = max_wait_experienced <= MAX_WAIT_TOLERANCE

    goodwill_cost = (total_wait_minutes / 60) * COST_PER_WAIT_HOUR

    net_profit = total_revenue - total_wages - goodwill_cost

    return net_profit, valid, max_wait_experienced

# --- DATA COLLECTION ---

results_A = []
results_B = []
results_C = []

print("Simulating Policy A...")
for k in range(1, 7):
    profits = []
    valids = []
    waits = []
    schedule = [k, k, k, k]
    for _ in range(NUM_RUNS):
        p, v, w = run_simulation(schedule)
        profits.append(p)
        valids.append(v)
        waits.append(w)

    results_A.append({
        "k": k,
        "profit": np.mean(profits),
        "feasible": np.mean(valids) > 0.9,
        "avg_max_wait": np.mean(waits)
    })

print("Simulating Policy B...")
for nb in [1, 2, 3]:
    for na in range(0, 7):
        if (nb + na) > 6: continue
        if (nb + na) < 1: continue
        schedule = [nb, nb+na, nb, nb]
        profits = []
        valids = []
        waits = []
        for _ in range(NUM_RUNS):
            p, v, w = run_simulation(schedule)
            profits.append(p)
            valids.append(v)
            waits.append(w)

        results_B.append({
            "nb": nb,
            "na": na,
            "profit": np.mean(profits),
            "feasible": np.mean(valids) > 0.9,
            "avg_max_wait": np.mean(waits)
        })

print("Simulating Policy C...")
for F in np.linspace(0.03, 0.15, 20):
    schedule = []
    impossible = False
    for b in BLOCKS:
        staff = math.ceil(F * b["lambda"])
        if staff > 6: impossible = True
        if staff < 1: staff = 1
        schedule.append(staff)

    if impossible: continue
    profits = []
    valids = []
    waits = []
    for _ in range(NUM_RUNS):
        p, v, w = run_simulation(schedule)
        profits.append(p)
        valids.append(v)
        waits.append(w)

    results_C.append({
        "F": F,
        "schedule": str(schedule),
        "profit": np.mean(profits),
        "feasible": np.mean(valids) > 0.9,
        "avg_max_wait": np.mean(waits)
    })

# --- PLOTTING ---

plt.style.use('seaborn-v0_8')
fig = plt.figure(figsize=(15, 10))

# Plot A
ax1 = fig.add_subplot(2, 2, 1)
df_A = pd.DataFrame(results_A)
ax1.plot(df_A['k'], df_A['profit'], marker='o', label='Net Profit')
infeas_A = df_A[~df_A['feasible']]
ax1.scatter(infeas_A['k'], infeas_A['profit'], color='red', marker='x', s=100, zorder=5)
ax1.set_title("Policy A: Uniform Staffing")
ax1.set_xlabel("k (Staff per block)")
ax1.set_ylabel("Net Profit (KRW)")
ax1.grid(True)

# Plot C
ax2 = fig.add_subplot(2, 2, 2)
df_C = pd.DataFrame(results_C)
ax2.plot(df_C['F'], df_C['profit'], marker='o', color='green', label='Net Profit')
infeas_C = df_C[~df_C['feasible']]
ax2.scatter(infeas_C['F'], infeas_C['profit'], color='red', marker='x', s=100, zorder=5)
ax2.set_title("Policy C: Proportional Staffing")
ax2.set_xlabel("F Factor")
ax2.set_ylabel("Net Profit (KRW)")
ax2.grid(True)

# Plot B (Heatmap)
ax3 = fig.add_subplot(2, 2, 3)
df_B = pd.DataFrame(results_B)
heatmap_data = df_B.pivot(index="nb", columns="na", values="profit")
sns.heatmap(heatmap_data, annot=True, fmt=".0f", cmap="RdYlGn", ax=ax3, cbar_kws={'label': 'Net Profit'})
ax3.set_title("Policy B Profit Heatmap")
ax3.set_xlabel("na (Additional Lunch Staff)")
ax3.set_ylabel("nb (Base Staff)")

# Text Summary
ax4 = fig.add_subplot(2, 2, 4)
ax4.axis('off')

def get_top_3(df, policy_name, param_col):
    valid_df = df.sort_values('profit', ascending=False)
    top = valid_df.head(3)
    txt = f"--- {policy_name} Best Parameters ---\n"
    if top.empty:
        txt += "No parameters found.\n"
    else:
        for _, row in top.iterrows():
            if policy_name == "Policy B":
                p_str = f"Base={row['nb']}, Add={row['na']}"
            elif policy_name == "Policy C":
                p_str = f"F={row['F']:.3f} {row['schedule']}"
            else:
                p_str = f"k={row['k']}"

            status = "OK" if row['feasible'] else "FAIL"
            txt += f"{p_str} | Profit: {row['profit']:,.0f} | {status}\n"
    return txt + "\n"

summary_text = get_top_3(df_A, "Policy A", "k")
summary_text += get_top_3(df_B, "Policy B", ["nb", "na"])
summary_text += get_top_3(df_C, "Policy C", "F")

ax4.text(0, 1, summary_text, fontsize=12, verticalalignment='top', fontfamily='monospace')

plt.tight_layout()
plt.show()